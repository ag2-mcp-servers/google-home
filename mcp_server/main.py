# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T00:35:36+00:00



import argparse
import json
import os
from typing import *

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header

from models import (
    AccessibilityRequest,
    AlarmVolumeRequest,
    AppDeviceIDRequest,
    BluetoothBondPostResponse,
    BluetoothConnectPostResponse,
    BluetoothDiscoveryPostResponse,
    BluetoothGetBondedGetResponse,
    BluetoothScanPostResponse,
    BluetoothScanResultsGetResponse,
    ChangeDiscoverabilityRequest,
    CheckReadyStatusRequest,
    ConfiguredNetworksGetResponse,
    ConnecttoWiFiNetworkRequest,
    DeleteAlarmsandTimersRequest,
    Example1,
    Example11,
    Example12,
    Example13,
    Example16,
    Example17,
    Example18,
    Example19,
    Example110,
    ForgetpaireddeviceRequest,
    ForgetWiFiNetworkRequest,
    ForgetWifiPostResponse,
    Getcurrentstate,
    Getcurrentvalues,
    Getvolume,
    NightModesettingsRequest,
    PairwithSpeakerRequest,
    RebootandFactoryResetRequest,
    RebootPostResponse,
    ScanfordevicesRequest,
    ScanResultsGetResponse,
    ScanWifiPostResponse,
    SetEqualizerValuesRequest,
    SetEurekaInfoPostResponse,
    SetEurekaInfoRequest,
    SupportedLocalesGetResponse,
    SupportedTimezonesGetResponse,
    TestInternetDownloadSpeedRequest,
    UserEqSetEqualizerPostResponse,
)

app = MCPProxy(
    contact={},
    description='# Google Home Local API\nThis is an unofficial documentation of the local API used by the Home app to communicate with GH devices.\n[GitHub Repo](https://github.com/rithvikvibhu/GHLocalApi)\n\n[![GitHub stars](https://img.shields.io/github/stars/rithvikvibhu/GHLocalApi)](https://github.com/rithvikvibhu/GHLocalApi/stargazers) [![GitHub license](https://img.shields.io/github/license/rithvikvibhu/GHLocalApi)](https://github.com/rithvikvibhu/GHLocalApi/blob/master/LICENSE.md)\n\n## Getting Started\n\nRequests must be made over HTTPS, port 8443, so the base URL for these endpoints is: `https://<google-home-ip>:8443/setup/`\n\nGet the IP of Google Home from the Google Home app (Device Settings -> End of the list) or from your router.\n\nGET requests are simple, in the browser kind.  \nPOST requests need to set the header (when there\'s a body): `content-type: application/json`\n\n## Authentication\n\nSince June 2019, most requests (with exceptions like `/setup/eureka_info`) need a local authorization token.\n\nThere are 3 kinds of tokens involved here:\n\n### Local Authorization Token\nThis token must be sent in all requests in the header `cast-local-authorization-token`. It is short-lived (~1 day) and may change unexpectedly (with a sync, change in homegraph, etc.)\n##### Get this token\n- With access to an android device, [get this token directly by either method](https://gist.github.com/rithvikvibhu/1a0f4937af957ef6a78453e3be482c1f).\n- Without a device, or to integrate it with a script, use an access token to get the homegraph and extract the token. To get an access token, read the next section. Check the example section for more info.\n\n### Access Token\nThis is a standard google oauth2 access token. It is in the form `ya29.***`.\nThis gives access to the Google Home Foyer API. These expire in an hour.\nUse this to get the homegraph (and then the local authorization token above).\n##### Get this token\nTo get this access token, either a Google account username/password or a Google Master Token is needed. More info in the gist.\nUse the script [from this gist](https://gist.github.com/rithvikvibhu/952f83ea656c6782fbd0f1645059055d).\n\n### Master Token\nThis is in the form `aas_et/***` and can be used to request access tokens.\n##### Get this token\nThe same [script in the gist](https://gist.github.com/rithvikvibhu/952f83ea656c6782fbd0f1645059055d) that gets the access token can also get the master token. Needs Google account creds.\n\n## Example\n\nHere\'s the whole flow from just a pair of username/password to using the local API.\n\nPrerequisites:\n- [grpcurl](https://github.com/fullstorydev/grpcurl)\n- [Proto files](https://drive.google.com/drive/folders/1RvnN3y-G23pd2SWHmfV_7sef8QU5GNF4?usp=sharing) (preserve folder structure)\n\n### 1. Get an access token with the script\n- Download get_tokens.py\n- Fill in username and password\n```sh\npython3 get_tokens.py\n# Note down the access token printed.\n```\n\n### 2. Use the access token and get home graph\n- This prints the json and uses jq to parse and filter out the fields deviceName and localAuthToken\n- This will give a list of all devices and their local auth tokens\n```sh\n./grpcurl -H \'authorization: Bearer ya29.a0Af****\' \\\n\t-import-path /path/to/protos \\\n\t-proto /path/to/protos/google/internal/home/foyer/v1.proto \\\n\tgooglehomefoyer-pa.googleapis.com:443 \\\n\tgoogle.internal.home.foyer.v1.StructuresService/GetHomeGraph | jq \'.home.devices[] | {deviceName, localAuthToken}\'\n# Note down the local auth token for the device you want.\n```\n\n### 3. Make the call to the local device using the local auth token\n```sh\ncurl -H "cast-local-authorization-token: LOCAL_AUTH_TOKEN" --verbose --insecure https://192.168.0.18:8443/setup/bluetooth/status\n```',
    title='Google Home',
    version='2.0',
    servers=[{'url': 'http://example.com/setup', 'variables': {}}],
)


@app.get(
    '/NOTICE.html.gz',
    description=""" All licenses of programs used by Home. """,
    tags=['user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def legal_notice():
    """
    Legal Notice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/a11y_mode',
    description=""" This controls Accessibility sounds. `hotword_enabled` is for 'Play start sound' and `endpoint_enabled` is for 'Play end sound'.  
Sending an empty-body POST request returns the current values.  
Either of the fields or both can be sent and new values will be saved. """,
    tags=['user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def accessibility(body: AccessibilityRequest):
    """
    Accessibility
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/assistant/alarms',
    description=""" This gives a list of all active alarms and timers.

Both alarms and timers have `id`s which can be used to delete them. (There is no known way of creating/deleting yet). The value of `status` have different meanings for alarms and timers (given below).

Alarms have `date_pattern` and `time_pattern` with day, month, year, hour, minute, second. `fire_time` is the same in unix time (milliseconds, not seconds).  
`status` is 1 for set up and 2 for ringing.

Timers have `original_duration` is the original duration.  
`status` is 1 for set up and 3 for ringing. """,
    tags=['alarm_and_timer_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def get_alarmsand_timers():
    """
    Get Alarms and Timers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/alarms/delete',
    description=""" This deletes alarms and timers by their id.

`ids` is a list of ids to be deleted. Sending invalid id still returns a 200 OK. The `/` in the ids have to be escaped like `\/`. """,
    tags=['alarm_and_timer_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def delete_alarmsand_timers(body: DeleteAlarmsandTimersRequest):
    """
    Delete Alarms and Timers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/alarms/volume',
    description=""" This gets and sets alarms and timers volume.  
**Note:** This is not the same as normal volume.

Volume is a float number in [0, 1] where 0 is minimum and 1 is maximum.  
Sending an empty body gets the volume. Sending `volume` sets the volume. """,
    tags=['alarm_and_timer_management', 'audio_configuration'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def alarm_volume(body: AlarmVolumeRequest):
    """
    Alarm Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/check_ready_status',
    description=""" **Update:** This seems to have changed now and is no longer possible. The error is also new.

Setting `play_ready_message` to true plays a welcome message on the device saying "Hi, I'm your Google Assistant. I'm here to help. To learn a few things you can do, continue in the Google Home app." """,
    tags=['device_status_checking'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def check_ready_status(body: CheckReadyStatusRequest):
    """
    Check Ready Status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/notifications',
    description=""" This is for the Do Not Disturb option. Sending an empty-body POST returns the current value. Sending a new value changes it. """,
    tags=['user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def do_not_disturb(content__type: str = Header(..., alias='Content-Type')):
    """
    Do Not Disturb
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/assistant/set_night_mode_params',
    description=""" This sets night mode options.  
To view currently set values, use /setup/eureka_info.  
If `enabled` is set to false, night mode is disabled and the other values do not matter.  
`led_brightness` and `volume` refer to the maximum LED Brightness and Volume that is set during night mode.  
`demo_to_user` is always set to `true` so change in values will be visible in realtime (like brightness).  
`windows`: A combination of `length_hours` and `start_hour` is used to define start and end times for night mode. In this example, night mode starts at 10 PM (22) and ends at 6 AM (8 hours later). `windows.days` is an array of days of week when night mode will be enabled. Example: 0->Sunday, 1-> Monday, ..., 6->Saturday. """,
    tags=['user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def night_modesettings(body: NightModesettingsRequest):
    """
    Night Mode settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bluetooth/bond',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For both parts**

This is to forget paired devices by mac address. Works for both kinds of devices (Part 1 and Part 2). """,
    tags=['device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def forgetpaireddevice(body: ForgetpaireddeviceRequest):
    """
    Forget paired device
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bluetooth/connect',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For Part 2 only**

This pairs with other bluetooth speakers by mac address. """,
    tags=['device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def pairwith_speaker(body: PairwithSpeakerRequest):
    """
    Pair with Speaker
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bluetooth/discovery',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For Part 1 only**

This enables/disables Home's bluetooth discovery and other devices can pair with Home (where Home acts as a speaker). """,
    tags=['device_management', 'user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def change_discoverability(body: ChangeDiscoverabilityRequest):
    """
    Change Discoverability
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bluetooth/get_bonded',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For both parts**

This gives a list of all paired or 'bonded' devices. The response field names are self-descriptive. """,
    tags=['device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def get_paired_devices():
    """
    Get Paired Devices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bluetooth/scan',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For Part 2 only**

This initiates scan for other bluetooth speakers/devices. Scan results will be updated continuously for `timeout` seconds.  
To get the scan results, see /setup/bluetooth/scan_results. """,
    tags=['device_management', 'network_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def scanfordevices(body: ScanfordevicesRequest):
    """
    Scan for devices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bluetooth/scan_results',
    description=""" *See note for Bluetooth under `/setup/bluetooth/status`*

**For Part 2 only**

This returns a list of all nearby bluetooth devices. While the Home app only shows speakers, this list contains all devices including TVs, mobiles, etc.

`rssi` is signal strength, `name` is name, `mac_address` is mac address.  
`device_class` and `device_type` are bluetooth codes.  

The Home app only lists those devices with `expected_profiles` > 0. Basically, the device should function as a speaker. """,
    tags=['network_management', 'device_status_checking'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def get_scan_results():
    """
    Get Scan Results
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bluetooth/status',
    description=""" > **There are 2 parts of Bluetooth.**
>
> *Part 1*: Devices like phones connect to Home and play audio through Home.  
> For this, /setup/bluetooth/discovery is used to make Home discoverable. Then devices can connect to it as if Home is just another bluetooth speaker.
>
> *Part 2*: Bluetooth speakers connect to Home and Home plays audio through the speakers.
> For this, /setup/bluetooth/scan and /setup/bluetooth/scan_results are used to connect to other speakers.
>
> The other endpoints are common for both parts.


**For both parts**

This gives the status of all bluetooth things.
- Not sure what `audio_mode` is.
- `discovery_enabled` states whether Home is discoverable. (**Part 1**)
- `connecting_devices` is a list of all media sources (like phones) connected to Home. (**Part 1**)
- `scanning_enabled` states whether Home scanning for other bluetooth speakers/devices. (**Part 2**)
- `connected_devices` is a list of all speakers connected to Home. (**Part 2**) """,
    tags=['device_status_checking'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def status():
    """
    Status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/configured_networks',
    description=""" This gets a list of all saved Wi-Fi networks.

Each network has `ssid`, `wpa_auth`, `wpa_cipher` and `wpa_id`.  
`wpa_id` is an incrementing number used to identify a saved network.  
#TODO: Add values for `wpa_auth` and `wpa_cipher`. """,
    tags=['network_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def get_saved_networks():
    """
    Get Saved Networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/connect_wifi',
    description=""" **Note:** Not sure how the password is encrypted. Might be using the public certificate from /setup/eureka_info. So this cannot be used as of now. If someone figures it out, please [create a new issue here](https://github.com/rithvikvibhu/GHLocalApi/issues/new). """,
    tags=['network_management', 'device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def connectto_wi__fi_network(body: ConnecttoWiFiNetworkRequest):
    """
    Connect to Wi-Fi Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/eureka_info',
    description=""" This gives most of the device info. The GET parameter `param` is a comma separated list of json keys to fetch. Currently, these params are known: `version,audio,name,build_info,detail,device_info,net,wifi,setup,settings,opt_in,opencast,multizone,proxy,night_mode_params,user_eq,room_equalizer,sign,aogh,ultrasound,mesh`

Nested items can also be filtered using the dot notation. Example: `audio.digital`

The `options` GET parameter is always set to `detail` or `detail,sign`. `sign` signs the `nonce` and returns some value.

The `nonce` GET parameter is an integer value signed with needed (see `option` parameter above). """,
    tags=['system_configuration_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def eureka_info(params: str, options: str = ..., nonce: int = ...):
    """
    Eureka Info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forget_wifi',
    description=""" This is to forget a saved network by `wpa_id`. Get the `wpa_id` from /setup/configured_networks """,
    tags=['network_management', 'device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def forget_wi__fi_network(body: ForgetWiFiNetworkRequest):
    """
    Forget Wi-Fi Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/get_app_device_id',
    description=""" This gives "app device id", "certificate" and "signed data".  
The `app_id` in the request is mandatory and refers to Chromecast backdrop/screensaver app. It has to be set to `E8C28D3C`.  

The certificate is valid and issued by `Chromecast ICA 6 (Audio Assist), Google Inc`.

Not sure what the other two are. """,
    tags=['device_management', 'user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def app_device_i_d(body: AppDeviceIDRequest):
    """
    App Device ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/icon.png',
    description=""" **Update:** This no longer exists. It's not useful, anyway.

A redirect to `http://www.gstatic.com/eureka/images/eureka_device.png` """,
    tags=['device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def chromecast_icon():
    """
    Chromecast Icon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/offer',
    description=""" This gives a token which is used by the Home app to get offers. The offers themselves are not stored on the device.  
A new token is generated for every request. """,
    tags=['user_settings_handling'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def offer():
    """
    Offer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reboot',
    description=""" This can simply reboot the device (`params: "now"`) or factory reset the device (`params: "fdr"`). """,
    tags=['system_configuration_management', 'device_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def rebootand_factory_reset(body: RebootandFactoryResetRequest):
    """
    Reboot and Factory Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scan_results',
    description=""" This gets a list of all nearby Wi-Fi access points.

The list only has the connected AP by default. Once a scan is triggered by `/setup/scan_wifi`, the whole list is cached for ~3 minutes. Then it will revert to returning only the connected AP again. """,
    tags=['network_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def get_wi__fi_scan_results():
    """
    Get Wi-Fi Scan Results
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scan_wifi',
    description=""" This initiates scanning for Wi-Fi networks.

The results can be obtained with `/setup/scan_results` after triggering the scan with this request. """,
    tags=['network_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def scanfor_networks():
    """
    Scan for Networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/set_eureka_info',
    description=""" This can set custom values to some options.

Only fields to be modified need to be sent, not all. The example has some modifiable fields.

TODO: List all modifiable fields.

Sending non-existant fields will still return a 200 OK, but they are not saved. """,
    tags=['system_configuration_management'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def set_eureka_info(body: SetEurekaInfoRequest):
    """
    Set Eureka Info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/supported_locales',
    description=""" Simply returns a list of all supported locales. """,
    tags=['localization_settings'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def locales():
    """
    Locales
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/supported_timezones',
    description=""" Simply returns a list of all supported timezones. """,
    tags=['localization_settings'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def timezones():
    """
    Timezones
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/test_internet_download_speed',
    description=""" **Update:** This seems to have been removed. Returns 404 Not Found.

This endpoint tests internet download speed. Any sample file URL can be provided. """,
    tags=['network_management', 'device_status_checking'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def test_internet_download_speed(body: TestInternetDownloadSpeedRequest):
    """
    Test Internet Download Speed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user_eq/set_equalizer',
    description=""" This can only set new equalizer values. To get already set values, use /setup/eureka_info.

The body is mandatory. It can either contain `low_shelf` or `high_shelf` or both.

`low_shelf.gain_db` and `high_shelf.gain_db` refer to **bass** and **treble** respectively.

Default values are 0 for both.  
While the slider in the Home app only ranges from -6 to +6, they can be set to any integer like 50 or -100. These changes persist. """,
    tags=['audio_configuration'],
    security=[
        APIKeyHeader(name="cast-local-authorization-token"),
    ],
)
def set_equalizer_values(body: SetEqualizerValuesRequest):
    """
    Set Equalizer Values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
